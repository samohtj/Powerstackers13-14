#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     SMUX,           sensorI2CCustom)
#pragma config(Sensor, S3,     sGyro,          sensorI2CCustom)
#pragma config(Sensor, S4,     sLiftStop,      sensorTouch)
#pragma config(Motor,  motorA,          mFlagRaise1,   tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          mFlagRaise2,   tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          mBlockStop,    tmotorNXT, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_1,     mDriveLeft,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     mDriveRight,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     mBsConveyor,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     mBsAngle,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    rConveyorTight,       tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    rBlockDropLeft,       tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    rBlockDropRight,      tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

///////////////////////////////////////////////////////
//
//	AUTONOMOUS MODE MAIN PROGRAM
//	CODE BY FTC TEAM# 5029
//	github.com/samohtj/PowerstackersFTC-5029
//	powerstackersftc.weebly.com
//	UPDATED 3-30-2014
//
///////////////////////////////////////////////////////

		// 1 wheel rot = 1350 ticks
#include "JoystickDriver.c"
#include "autonomous-includes/autonomousTasks.h"

///////////////////////////////////////////////////////
//
//	MAIN TASK
//
///////////////////////////////////////////////////////
task main()
{

	StartTask(runMenuOffensive);
	StartTask(getSmux);
	PlaySound(soundUpwardTones);
	wait10Msec(200);
	initializeRobot();

	waitForStart();

	StopTask(runMenuOffensive);
	printMenuChoices();
	StartTask(showDebugInfo);

	startEncoderPos = nMotorEncoder[mDriveRight];

	if(delay > 0) {
		writeDebugStreamLine("Wait detected");
		wait10Msec(delay * 100);
		writeDebugStreamLine("Wait over");
	}

	// Raise the brick sucker plate a few inches above the ground,
	// to keep it from hitting the ramp
	long targetArmPos = nMotorEncoder[mBsAngle] + 300;
	while(nMotorEncoder[mBsAngle] < targetArmPos) {
		motor[mBsAngle] = 100;
	}
	motor[mBsAngle] = 0;

	if(doIr) {
		findIrIncremental();
		if(goAround) {
			writeDebugStreamLine("Going to far end of ramp");
			long farEncoderPos = startEncoderPos + inchesToTicks(68);
			goTicks(farEncoderPos - nMotorEncoder[mDriveRight], 100);
		} else {
			// If the robot started on the near side of the ramp, go back a little further
			long nearEncoderPos;
			if(startNear)
				nearEncoderPos = startEncoderPos + inchesToTicks(2);
			else
				nearEncoderPos = startEncoderPos + inchesToTicks(12);

			writeDebugStreamLine("Going to near end of ramp");
			goTicks(-1 * (nMotorEncoder[mDriveRight] - nearEncoderPos), 100);
		}

		if(startNear){
			turnDegrees(-90, turnSpeed);

			findWhiteLine();

			if(!rampOtherSide) {
				goTicks(inchesToTicks(6), 50);
			} else {
				goTicks(inchesToTicks(-6), 50);
			}

			if(goAround) {
				turnDegrees(50, turnSpeed);
			} else {
				turnDegrees(-80, turnSpeed);
			}
		} else {
			// Turn a little bit more or less if we're on the far or near side,
			// to avoid hitting the ramp
			if(goAround) {
				turnDegrees(70, turnSpeed);
			} else {
				turnDegrees(80, turnSpeed);
			}

			findWhiteLine();

			if(!rampOtherSide) {
				goTicks(inchesToTicks(6), 50);
			} else {
				goTicks(inchesToTicks(-6), 50);
			}

			if(goAround) {
				turnDegrees(-60, turnSpeed);
			} else {
				turnDegrees(60, turnSpeed);
			}
		}

		// Go up the ramp, and turn 90 degrees so we can't be pushed
		goTicks(inchesToTicks(-40), 100);
		turnDegrees(80, 50);
	} else {
		// If the user has chosen not to place the IR block
		// (This is where a defensive game option would go)
		writeDebugStreamLine("Did not do IR. You really should have.");
	}
}
