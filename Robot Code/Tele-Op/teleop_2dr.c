
#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     SMUX,           sensorI2CCustom)
#pragma config(Sensor, S3,     sGyro,          sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     sConvStop,      sensorTouch)
#pragma config(Motor,  motorA,          mFlagRaise1,   tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          mFlagRaise2,   tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          mBlockStop,    tmotorNXT, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_1,     mDriveLeft,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     mDriveRight,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     mBsConveyor,   tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     mBsAngle,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    rConveyorTight,       tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    rBlockDropLeft,       tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    rBlockDropRight,      tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	TELE-OP CODE FOR FTC# 5029
//	2013-2014 BLOCK PARTY
//	UPDATED 3-31-14
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Include the file to run the motors and servos, and get joystick input
#include "JoystickDriver.c"

// STICK_TO_MOTOR: Convert the joystick's -128 - +127 value into a -99 - +100 value
#define STICK_TO_MOTOR(x)	((float)x * 0.78125)
#define MODE_STRAIGHT true
#define MODE_NORMAL false

short stickDriveLeft;
short stickDriveRight;
short stickAngle;
short stickBlockStop;

bool btnStraightDr;
bool btnConveyor;
bool btnReverse;
bool btnFlagClock;
bool btnFlagCounter;
bool btnConveyorTight;

bool driveMode;
//bool brickBlocked = true;
//bool blockerMoving = false;

const short stickThreshold = 10;
const int blockClosedPos = 90;
const int blockOpenPos = -5;
const int blockOpenThresh = -360;
const int blockClosedThresh = 360;
const int blockSpeed = 50;

/////////////////////////////////////////////////////
//
//	Set all motors to the input parameter value
//
/////////////////////////////////////////////////////
void allMotorsTo(int i)
{
	motor[mDriveLeft] = i;
	motor[mDriveRight] = i;
	motor[mBsAngle] = i;
	motor[mBsConveyor] = i;
	motor[mBlockStop] = i;
	motor[mFlagRaise1] = i;
	motor[mFlagRaise2] = i;
}

///////////////////////////////////////////////////////
//
//	Set all drive motors to the input parameter value
//
///////////////////////////////////////////////////////
void driveMotorsTo(int i)
{
	motor[mDriveLeft] 	= i;
	motor[mDriveRight] 	= i;
}

///////////////////////////////////////////////////
//
//	Set all encoders to the input parameter value
//
///////////////////////////////////////////////////
void allEncodersTo(int i)
{
	nMotorEncoder[mBlockStop] = i;
	nMotorEncoder[mBsAngle] = i;
	nMotorEncoder[mBsConveyor] = i;
	nMotorEncoder[mDriveLeft] = i;
	nMotorEncoder[mDriveRight] = i;
	writeDebugStreamLine("Encoders initialized");
}

///////////////////////////////////////////////////////////////
//
//	Initialize motor and servo values before the match starts
//
///////////////////////////////////////////////////////////////
void initializeRobot()
{
	allMotorsTo(0);
	allEncodersTo(0);
	servo[rBlockDropLeft] = 128;
	servo[rBlockDropRight] = 128;
	servo[rConveyorTight] = 150;
	PlaySound(soundUpwardTones);
	nxtDisplayCenteredBigTextLine(2, "Tele-Op");
	nxtDisplayCenteredBigTextLine(4, "Ready");
	return;
}

//////////////////////////////////////////////////////////////
//
//	Copy the Joystick values into the custom variables
//
//////////////////////////////////////////////////////////////
void getCustomJoystickSettings()
{
	stickDriveLeft 	= joystick.joy1_y1;		// dr1 left joystick
	stickDriveRight = joystick.joy1_y2;		// dr1 right joystick
	stickAngle		= joystick.joy2_y1;		// dr2 left joystick
	stickBlockStop	=	joystick.joy2_y2;	// dr2 right joystick
	btnStraightDr	= (joy1Btn(3) == 1);	// dr1 red button
	btnFlagClock	= (joy1Btn(5) == 1);	// dr1 left shoulder
	btnFlagCounter	= (joy1Btn(7) == 1);	// dr1 left trigger
	btnReverse		= (joy2Btn(8) == 1);	// dr2 right trigger
	btnConveyor		=	(joy2Btn(6) == 1);	// dr2 right shoulder
	btnConveyorTight =(joy2Btn(7) == 1);	// dr2 left trigger
}

//////////////////////////////////////////////////////////////
//
//	Print custom information to the NXT screen
//
/////////////////////////////////////////////////////////////
void displayButtonValues()
{
	nxtDisplayTextLine(1, "blockStop enc: %d",	nMotorEncoder[mBlockStop]);
	nxtDisplayTextLine(3, "stickBlSt:%d", stickBlockStop);
	nxtDisplayTextLine(4, "mtrBlock:%d", motor[mBlockStop]);
  	nxtDisplayTextLine(5, "bsAngle:%d", nMotorEncoder[mBsAngle]);
	nxtDisplayTextLine(6, "stickAngle:%d", stickAngle);
}

///////////////////////////////////////////////
//
//	MAIN TASK
//
//////////////////////////////////////////////
task main()
{
	bDisplayDiagnostics = false;
	clearDebugStream();
	eraseDisplay();
	initializeRobot();
	ClearTimer(T1);
	nNoMessageCounterLimit = 500;


	waitForStart();
	nxtDisplayCenteredBigTextLine(4, "Running");
	PlaySound(soundFastUpwardTones);

  // Loop forever
  while (true) {
		getJoystickSettings(joystick);
		getCustomJoystickSettings();

		// If the robot loses connection, play and obnoxious sound
		// And print a big, scary "LOST CONNECTION" to the NXT screen
		// Until the robot regains connection
		if(bDisconnected) {
			allMotorsTo(0);
			while(bDisconnected) {
				nxtDisplayCenteredBigTextLine(2, "LOST");
				nxtDisplayCenteredBigTextLine(4, "CONNECT");
				nxtDisplayCenteredBigTextLine(6, "-ION");
				PlaySound(soundException);
			}
			ClearSounds();
			nxtDisplayCenteredBigTextLine(2, "Tele-Op");
			nxtDisplayCenteredBigTextLine(4, "Running");
			nxtDisplayCenteredBigTextLine(6, "");
			PlaySound(soundFastUpwardTones);
		}
		// Straight drive mode:
		// If the straight drive button is pressed, set the drive mode to Straight
		// If the straight drive button is not pressed, set the drive mode to Normal
		if(btnStraightDr){
			driveMode = MODE_STRAIGHT;
		}else{
			driveMode = MODE_NORMAL;
		}

		// If the drive mode is set to straight, move both motors at the same speed
		if (driveMode == MODE_STRAIGHT){
			if(abs(stickDriveLeft) > stickThreshold){
					driveMotorsTo(STICK_TO_MOTOR(stickDriveLeft));
			}else{
				driveMotorsTo(0);
			}
		} else if(driveMode == MODE_NORMAL) {

			if(abs(stickDriveLeft) < stickThreshold) {
				motor[mDriveLeft] = 0;
			} else{
				motor[mDriveLeft] = STICK_TO_MOTOR(stickDriveLeft);
			}

			if(abs(stickDriveRight) < stickThreshold) {
				motor[mDriveRight] = 0;
			} else {
				motor[mDriveRight] = STICK_TO_MOTOR(stickDriveRight);
			}
		}

		if(btnConveyor) {
			motor[mBsConveyor] = 100;
		} else if(btnReverse) {
			motor[mBsConveyor] = -100;
		} else{
			motor[mBsConveyor] = 0;
		}

		if(abs(stickAngle) < stickThreshold){
			motor[mBsAngle] = 0;
		} else {
			// Don't move the block sucker down if the touch sensor is active
			if(stickAngle < 0 && SensorValue[sConvStop] == 1) {
				motor[mBsAngle] = 0;
				nMotorEncoder[mBsAngle] = 0;
			} else {
				motor[mBsAngle] = ((stickAngle > 0)? 100 : -100);
			}
		}

		// Do not let the block gate go above certain values
		// This keeps it from turning too far and damaging the motors
		if(abs(stickBlockStop) < stickThreshold) {
			motor[mBlockStop] = 0;
		} else if(nMotorEncoder[mBlockStop] >= blockOpenThresh && stickBlockStop > 0) {
				if(nMotorEncoder[mBlockStop] < blockClosedPos) {
					motor[mBlockStop] = blockSpeed;
				} else {
					motor[mBlockStop] = 0;
				}
		} else if(nMotorEncoder[mBlockStop] <= blockClosedThresh && stickBlockStop < 0) {
			if(nMotorEncoder[mBlockStop] > blockOpenPos) {
				motor[mBlockStop] = blockSpeed * -1;
			} else {
				motor[mBlockStop] = 0;
			}
		} else {
			motor[mBlockStop] = 0;
		}

		if(btnFlagClock){
			if(!btnFlagCounter) {
				motor[mFlagRaise1] = 100;
				motor[mFlagRaise2] = 100;
			}
		} else if(btnFlagCounter) {
			motor[mFlagRaise1] = -100;
			motor[mFlagRaise2] = -100;
		} else {
			motor[mFlagRaise1] = 0;
			motor[mFlagRaise2] = 0;
		}

		if(btnConveyorTight){
			servo[rConveyorTight] = 170;
		}else{
			servo[rConveyorTight] = 150;
		}

		// If the sucker plate is above a certain height,
		// move the flipper servos out of the way
		if(nMotorEncoder[mBsAngle] > 3000) {
			servo[rBlockDropLeft] = 118;
			servo[rBlockDropRight] = 128;
		} else {
			servo[rBlockDropLeft] = 32;
			servo[rBlockDropRight] = 200;
		}
	}
}
